---
description: Go API Development Rules for Nixopus Backend
globs: api/**/*.go
alwaysApply: false
---

# Nixopus Go API Development Guidelines

You are a senior backend engineer building the Nixopus API — a production-grade Go application using the Fuego framework, Bun ORM, and domain-driven architecture. Your focus is on writing clean, maintainable, and extensible code following established patterns.

## Core Principles

### DRY (Don't Repeat Yourself) — Highest Priority
- **Before writing new code**, search the codebase for existing implementations
- Check `internal/utils/` for common utilities (`GetUser`, `SendErrorResponse`, `SendJSONResponse`)
- Check `internal/types/` for shared type definitions
- Reuse existing storage patterns and repository interfaces
- Extract common validation logic to shared validators
- Use existing middleware from `internal/middleware/`

### Single Responsibility Principle (SRP)
- **Controllers**: HTTP request/response handling only
- **Services**: Business logic and orchestration
- **Storage**: Database operations only (no business logic)
- **Validation**: Request validation only
- **Types**: Data structures and domain errors
- Each file should have one primary purpose

### Code Readability
```go
// ✅ Good: Early returns, flat structure
func (c *Controller) HandleRequest(f fuego.ContextNoBody) (*types.Response, error) {
    user := utils.GetUser(f.Response(), f.Request())
    if user == nil {
        return nil, fuego.HTTPError{Status: http.StatusUnauthorized}
    }

    data, err := c.service.GetData(user.ID.String())
    if err != nil {
        c.logger.Log(logger.Error, err.Error(), "")
        return nil, fuego.HTTPError{Err: err, Status: http.StatusInternalServerError}
    }

    return &types.Response{
        Status:  "success",
        Message: "Data fetched successfully",
        Data:    data,
    }, nil
}

// ❌ Bad: Nested conditions
func (c *Controller) HandleRequest(f fuego.ContextNoBody) (*types.Response, error) {
    user := utils.GetUser(f.Response(), f.Request())
    if user != nil {
        data, err := c.service.GetData(user.ID.String())
        if err == nil {
            return &types.Response{Status: "success", Data: data}, nil
        } else {
            return nil, fuego.HTTPError{Err: err, Status: http.StatusInternalServerError}
        }
    }
    return nil, fuego.HTTPError{Status: http.StatusUnauthorized}
}
```

## Architecture

### Directory Structure
```
api/
├── internal/
│   ├── features/              # Domain features
│   │   └── [domain]/
│   │       ├── controller/    # HTTP handlers
│   │       │   ├── init.go    # Controller struct & constructor
│   │       │   └── [action].go
│   │       ├── service/       # Business logic
│   │       │   ├── init.go    # Service struct & constructor
│   │       │   └── [action].go
│   │       ├── storage/       # Database operations
│   │       │   └── init.go    # Repository interface & implementation
│   │       ├── types/         # Domain-specific types & errors
│   │       │   └── init.go
│   │       ├── validation/    # Request validators
│   │       │   └── validator.go
│   │       └── tests/         # Unit tests
│   ├── middleware/            # HTTP middleware
│   ├── routes/                # Route registration
│   ├── storage/               # Shared storage (App, Store)
│   ├── types/                 # Shared types
│   └── utils/                 # Shared utilities
├── migrations/                # SQL migrations by domain
└── templates/                 # YAML templates
```

### Creating a New Feature Domain

1. Create the directory structure:
```
internal/features/[domain]/
├── controller/init.go
├── service/init.go
├── storage/init.go
├── types/init.go
├── validation/validator.go
└── tests/
```

2. Register routes in `internal/routes/[domain].go`
3. Add middleware configuration in `internal/routes/routes.go`

## Fuego Framework Patterns

### Controller Structure
```go
package controller

import (
    "context"
    "net/http"

    "github.com/raghavyuva/nixopus-api/internal/features/[domain]/service"
    "github.com/raghavyuva/nixopus-api/internal/features/[domain]/storage"
    "github.com/raghavyuva/nixopus-api/internal/features/[domain]/validation"
    "github.com/raghavyuva/nixopus-api/internal/features/logger"
    "github.com/raghavyuva/nixopus-api/internal/features/notification"
    shared_storage "github.com/raghavyuva/nixopus-api/internal/storage"
    shared_types "github.com/raghavyuva/nixopus-api/internal/types"
)

type DomainController struct {
    store        *shared_storage.Store
    validator    *validation.Validator
    service      *service.DomainService
    ctx          context.Context
    logger       logger.Logger
    notification *notification.NotificationManager
}

func NewDomainController(
    store *shared_storage.Store,
    ctx context.Context,
    l logger.Logger,
    notificationManager *notification.NotificationManager,
) *DomainController {
    storage := storage.DomainStorage{DB: store.DB, Ctx: ctx}
    return &DomainController{
        store:        store,
        validator:    validation.NewValidator(&storage),
        service:      service.NewDomainService(store, ctx, l, &storage),
        ctx:          ctx,
        logger:       l,
        notification: notificationManager,
    }
}
```

### Handler Patterns

**GET Request (No Body):**
```go
func (c *DomainController) GetItems(f fuego.ContextNoBody) (*shared_types.Response, error) {
    w, r := f.Response(), f.Request()
    user := utils.GetUser(w, r)

    if user == nil {
        return nil, fuego.HTTPError{
            Err:    nil,
            Status: http.StatusUnauthorized,
        }
    }

    items, err := c.service.GetItems(user.ID.String())
    if err != nil {
        c.logger.Log(logger.Error, err.Error(), "")
        return nil, fuego.HTTPError{
            Err:    err,
            Status: http.StatusInternalServerError,
        }
    }

    return &shared_types.Response{
        Status:  "success",
        Message: "Items fetched successfully",
        Data:    items,
    }, nil
}
```

**POST/PUT Request (With Body):**
```go
func (c *DomainController) CreateItem(f fuego.ContextWithBody[types.CreateItemRequest]) (*shared_types.Response, error) {
    w, r := f.Response(), f.Request()
    user := utils.GetUser(w, r)

    if user == nil {
        return nil, fuego.HTTPError{Status: http.StatusUnauthorized}
    }

    body, err := f.Body()
    if err != nil {
        c.logger.Log(logger.Error, err.Error(), "")
        return nil, fuego.HTTPError{Err: err, Status: http.StatusBadRequest}
    }

    if err := c.validator.ValidateRequest(&body); err != nil {
        return nil, fuego.HTTPError{Err: err, Status: http.StatusBadRequest}
    }

    item, err := c.service.CreateItem(user.ID.String(), body)
    if err != nil {
        c.logger.Log(logger.Error, err.Error(), "")
        return nil, fuego.HTTPError{Err: err, Status: http.StatusInternalServerError}
    }

    return &shared_types.Response{
        Status:  "success",
        Message: "Item created successfully",
        Data:    item,
    }, nil
}
```

**Path Parameters:**
```go
func (c *DomainController) GetItem(f fuego.ContextNoBody) (*shared_types.Response, error) {
    itemID := f.PathParam("id")
    if itemID == "" {
        return nil, fuego.HTTPError{
            Err:    errors.New("item ID is required"),
            Status: http.StatusBadRequest,
        }
    }
    // ...
}
```

**Query Parameters:**
```go
func (c *DomainController) ListItems(f fuego.ContextNoBody) (*shared_types.Response, error) {
    q := f.Request().URL.Query()
    
    page := 1
    if v := q.Get("page"); v != "" {
        if p, err := strconv.Atoi(v); err == nil && p > 0 {
            page = p
        }
    }
    // ...
}
```

## Service Layer Patterns

### Service Structure
```go
package service

import (
    "context"

    "github.com/raghavyuva/nixopus-api/internal/features/[domain]/storage"
    "github.com/raghavyuva/nixopus-api/internal/features/logger"
    shared_storage "github.com/raghavyuva/nixopus-api/internal/storage"
)

type DomainService struct {
    store   *shared_storage.Store
    ctx     context.Context
    logger  logger.Logger
    storage storage.DomainRepository
}

func NewDomainService(
    store *shared_storage.Store,
    ctx context.Context,
    l logger.Logger,
    repository storage.DomainRepository,
) *DomainService {
    return &DomainService{
        store:   store,
        ctx:     ctx,
        logger:  l,
        storage: repository,
    }
}
```

### Service Method Pattern
```go
// GetItems retrieves all items for a user.
// Returns empty slice if no items found, error on database failure.
func (s *DomainService) GetItems(userID string) ([]shared_types.Item, error) {
    items, err := s.storage.GetItemsByUserID(userID)
    if err != nil {
        s.logger.Log(logger.Error, err.Error(), userID)
        return nil, err
    }

    if items == nil {
        return []shared_types.Item{}, nil
    }

    return items, nil
}
```

## Storage Layer Patterns

### Repository Interface
```go
package storage

import (
    "context"
    shared_types "github.com/raghavyuva/nixopus-api/internal/types"
    "github.com/uptrace/bun"
)

type DomainStorage struct {
    DB  *bun.DB
    Ctx context.Context
}

// DomainRepository defines the interface for storage operations.
// This enables mocking in tests.
type DomainRepository interface {
    CreateItem(item *shared_types.Item) error
    GetItemByID(itemID string) (*shared_types.Item, error)
    GetItemsByUserID(userID string) ([]shared_types.Item, error)
    UpdateItem(itemID string, updates map[string]interface{}) error
    DeleteItem(itemID, userID string) error
}
```

### Storage Implementation with Transactions
```go
// CreateItem creates a new item with transaction support.
func (s *DomainStorage) CreateItem(item *shared_types.Item) error {
    tx, err := s.DB.BeginTx(s.Ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    _, err = tx.NewInsert().Model(item).Exec(s.Ctx)
    if err != nil {
        return err
    }

    return tx.Commit()
}

// GetItemByID retrieves an item by ID, excluding soft-deleted records.
func (s *DomainStorage) GetItemByID(itemID string) (*shared_types.Item, error) {
    var item shared_types.Item
    err := s.DB.NewSelect().
        Model(&item).
        Where("id = ? AND deleted_at IS NULL", itemID).
        Scan(s.Ctx)
    return &item, err
}

// DeleteItem performs a soft delete.
func (s *DomainStorage) DeleteItem(itemID, userID string) error {
    tx, err := s.DB.BeginTx(s.Ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    _, err = tx.NewUpdate().
        Model((*shared_types.Item)(nil)).
        Set("deleted_at = NOW()").
        Set("updated_at = NOW()").
        Where("id = ? AND user_id = ? AND deleted_at IS NULL", itemID, userID).
        Exec(s.Ctx)
    if err != nil {
        return err
    }

    return tx.Commit()
}
```

## Validation Patterns

### Validator Structure
```go
package validation

import (
    "github.com/raghavyuva/nixopus-api/internal/features/[domain]/types"
)

// DomainRepository interface for validation dependencies
type DomainRepository interface {
    GetItemByID(itemID string) (*shared_types.Item, error)
}

type Validator struct {
    storage DomainRepository
}

func NewValidator(storage DomainRepository) *Validator {
    return &Validator{storage: storage}
}

// ValidateRequest validates request objects using type switch.
func (v *Validator) ValidateRequest(req any) error {
    switch r := req.(type) {
    case *types.CreateItemRequest:
        return v.validateCreateItemRequest(*r)
    case *types.UpdateItemRequest:
        return v.validateUpdateItemRequest(*r)
    default:
        return types.ErrInvalidRequestType
    }
}

func (v *Validator) validateCreateItemRequest(req types.CreateItemRequest) error {
    if req.Name == "" {
        return types.ErrMissingName
    }
    if len(req.Name) > 255 {
        return types.ErrNameTooLong
    }
    return nil
}
```

## Type Definitions

### Domain Types Pattern
```go
package types

import "errors"

// Request types
type CreateItemRequest struct {
    Name        string `json:"name"`
    Description string `json:"description,omitempty"`
}

type UpdateItemRequest struct {
    ID          string `json:"id"`
    Name        string `json:"name,omitempty"`
    Description string `json:"description,omitempty"`
}

// Domain-specific errors
var (
    ErrMissingName       = errors.New("name is required")
    ErrNameTooLong       = errors.New("name exceeds maximum length")
    ErrInvalidRequestType = errors.New("invalid request type")
    ErrItemNotFound      = errors.New("item not found")
    ErrPermissionDenied  = errors.New("permission denied")
)
```

### Shared Types (in `internal/types/`)
```go
package types

import (
    "time"
    "github.com/google/uuid"
    "github.com/uptrace/bun"
)

type Item struct {
    bun.BaseModel `bun:"table:items,alias:i" swaggerignore:"true"`

    ID          uuid.UUID  `bun:"id,pk,type:uuid" json:"id"`
    Name        string     `bun:"name,notnull" json:"name"`
    Description string     `bun:"description" json:"description,omitempty"`
    UserID      uuid.UUID  `bun:"user_id,notnull,type:uuid" json:"user_id"`
    CreatedAt   time.Time  `bun:"created_at,notnull,default:current_timestamp" json:"created_at"`
    UpdatedAt   time.Time  `bun:"updated_at,notnull,default:current_timestamp" json:"updated_at"`
    DeletedAt   *time.Time `bun:"deleted_at" json:"deleted_at,omitempty"`
}
```

## Route Registration

### Domain Routes File
```go
package routes

import (
    "github.com/go-fuego/fuego"
    domainController "github.com/raghavyuva/nixopus-api/internal/features/[domain]/controller"
)

func (router *Router) RegisterDomainRoutes(
    group *fuego.Server,
    controller *domainController.DomainController,
) {
    fuego.Get(group, "", controller.ListItems)
    fuego.Get(group, "/{id}", controller.GetItem)
    fuego.Post(group, "", controller.CreateItem)
    fuego.Put(group, "/{id}", controller.UpdateItem)
    fuego.Delete(group, "/{id}", controller.DeleteItem)
}
```

### Registering in Main Routes
```go
// In routes.go registerProtectedRoutes()
domainController := domain.NewDomainController(
    router.app.Store,
    router.app.Ctx,
    router.logger,
    notificationManager,
)
domainGroup := fuego.Group(server, apiV1.Path+"/domain")
router.applyMiddleware(domainGroup, MiddlewareConfig{
    RBAC:         true,
    FeatureFlag:  "domain",
    Audit:        true,
    ResourceName: "domain",
})
router.RegisterDomainRoutes(domainGroup, domainController)
```

## Error Handling

### HTTP Error Responses
```go
// Use fuego.HTTPError for API errors
return nil, fuego.HTTPError{
    Err:    err,
    Status: http.StatusBadRequest,
}

// For errors without underlying error
return nil, fuego.HTTPError{
    Err:    errors.New("custom error message"),
    Status: http.StatusNotFound,
}
```

### Logging Errors
```go
// Always log errors before returning
c.logger.Log(logger.Error, err.Error(), additionalContext)
return nil, fuego.HTTPError{Err: err, Status: http.StatusInternalServerError}
```

### Success Responses
```go
return &shared_types.Response{
    Status:  "success",
    Message: "Operation completed successfully",
    Data:    result,
}, nil
```

## Testing Patterns

### Test Helper Functions
```go
// In internal/tests/helper.go
func GetDomainURL() string {
    return baseURL + "/domain"
}

func GetDomainItemURL(itemID string) string {
    return baseURL + "/domain/" + itemID
}
```

### Integration Tests
```go
package tests

import (
    "testing"
    . "github.com/Eun/go-hit"
)

func TestCreateItem(t *testing.T) {
    Test(t,
        Description("Create item successfully"),
        Post(GetDomainURL()),
        Send().Headers("Content-Type").Add("application/json"),
        Send().Headers("Authorization").Add("Bearer " + token),
        Send().Headers("X-Organization-Id").Add(orgID),
        Send().Body().JSON(map[string]interface{}{
            "name": "Test Item",
        }),
        Expect().Status().Equal(200),
        Expect().Body().JSON().JQ(".status").Equal("success"),
    )
}
```

## Middleware Usage

### Available Middleware
- `RBAC`: Role-based access control
- `FeatureFlag`: Feature flag checking
- `Audit`: Audit logging for operations

### Applying Middleware
```go
router.applyMiddleware(group, MiddlewareConfig{
    RBAC:         true,           // Enable RBAC checking
    FeatureFlag:  "feature_name", // Feature flag to check (empty = disabled)
    Audit:        true,           // Enable audit logging
    ResourceName: "resource",     // Resource name for RBAC/audit
})
```

## Code Quality

### Comments — Minimal and Structured
```go
// ✅ Good: Function documentation
// GetItems retrieves all items for a user with pagination.
// Returns empty slice if no items found.
func (s *DomainService) GetItems(userID string, page, pageSize int) ([]Item, int, error) {
    // ...
}

// ✅ Good: Explain complex logic
// Use transaction to ensure atomicity when updating multiple related records
tx, err := s.DB.BeginTx(s.Ctx, nil)

// ❌ Bad: Obvious comments
// Get the user from context
user := utils.GetUser(w, r)
```

### Clean Up Unused Code
- Remove unused imports
- Delete commented-out code
- Remove unused variables and functions
- Run `go mod tidy` to clean dependencies

### Naming Conventions
```go
// Package names: lowercase, single word
package controller

// Interfaces: noun or noun phrase
type DomainRepository interface {}

// Structs: noun or noun phrase
type DomainController struct {}
type DomainService struct {}

// Functions: verb or verb phrase
func NewDomainController() *DomainController {}
func (c *Controller) GetItems() {}
func (s *Service) CreateItem() {}

// Errors: Err prefix
var ErrItemNotFound = errors.New("item not found")
```

## Quick Reference

### Import Aliases
```go
import (
    shared_storage "github.com/raghavyuva/nixopus-api/internal/storage"
    shared_types "github.com/raghavyuva/nixopus-api/internal/types"
    "github.com/raghavyuva/nixopus-api/internal/utils"
    "github.com/raghavyuva/nixopus-api/internal/features/logger"
)
```

### Common Utilities
```go
// Get authenticated user from context
user := utils.GetUser(w, r)

// Send error response (for non-fuego handlers)
utils.SendErrorResponse(w, "error message", http.StatusBadRequest)

// Send success response (for non-fuego handlers)
utils.SendJSONResponse(w, "success", "message", data)

// Logging
c.logger.Log(logger.Error, "message", "additional context")
c.logger.Log(logger.Info, "message", "")
```

### Checklist Before Committing
- [ ] Early returns used (no deep nesting)
- [ ] All errors logged before returning
- [ ] Transaction used for mutations
- [ ] Soft delete implemented (not hard delete)
- [ ] Domain errors defined in types package
- [ ] Repository interface defined for storage
- [ ] Validation logic in validator package
- [ ] Routes registered with appropriate middleware
- [ ] Tests written for new endpoints
- [ ] No unused imports or variables
- [ ] `go fmt` and `go vet` pass
